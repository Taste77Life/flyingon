<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
</head>
<body>

    <script type="text/javascript">

        //function Class() {

        //    var _value = 1;

        //    this.getValue = function () {

        //        return _value;
        //    };

        //    this.setValue = function (value) {

        //        _value = value;
        //    };
        //};

        //var result = {};
        //result.__proto__ = Class.prototype;
        //Class.call(result);
        //return result;


        //function Class() {

        //    this._value = 1;
        //};

        //Class.prototype.getValue = function () {

        //    return this._value;
        //};

        //Class.prototype.setValue = function (value) {

        //    this._value = value;
        //};

        //new Class().getValue();
        //alert(new Class().getValue == new Class().getValue);



        //function superClass() {

        //};

        //superClass.prototype.show = function () {

        //    alert("superClass");
        //};

        //function subClass() {

        //};

        //subClass.prototype = new superClass();

        //subClass.prototype.show = function () {

        //    alert("subClass");
        //};



        //new superClass().show(); //此处显示"superClass"
        //new subClass().show();   //此处显示"subClass"



        /* Simple JavaScript Inheritance
        * By John Resig http://ejohn.org/
        * MIT Licensed.
        */
        // Inspired by base2 and Prototype
        (function () {

            var initializing = false, fnTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

            // The base Class implementation (does nothing)
            this.Class = function () { };

            // Create a new Class that inherits from this class
            Class.extend = function (prop) {

                var _super = this.prototype;

                // Instantiate a base class (but only create the instance,
                // don't run the init constructor)
                initializing = true;
                var prototype = new this();
                initializing = false;

                // Copy the properties over onto the new prototype
                for (var name in prop)
                {
                    // Check if we're overwriting an existing function
                    prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? (function (name, fn) {

                        return function () {

                            var tmp = this._super;

                            // Add a new ._super() method that is the same method
                            // but on the super-class
                            this._super = _super[name];

                            // The method only need to be bound temporarily, so we
                            // remove it when we're done executing
                            var ret = fn.apply(this, arguments);
                            this._super = tmp;

                            return ret;
                        };

                    })(name, prop[name]) : prop[name];
                }

                // The dummy class constructor
                function Class() {

                    // All construction is actually done in the init method
                    if (!initializing && this.init)
                        this.init.apply(this, arguments);
                }

                // Populate our constructed prototype object
                Class.prototype = prototype;

                // Enforce the constructor to be what we expect
                Class.prototype.constructor = Class;

                // And make this class extendable
                Class.extend = arguments.callee;

                return Class;
            };

        })();



var Person = Class.extend({

    init: function (isDancing) {
        this.dancing = isDancing;
    },
    dance: function () {
        return this.dancing;
    }
});

var Ninja = Person.extend({

    init: function () {
        this._super(false);
    },
    dance: function () {
        // Call the inherited version of dance()
        return this._super();
    },
    swingSword: function () {
        return true;
    }
});

var p = new Person(true);
p.dance(); // => true

var n = new Ninja();
n.dance(); // => false
n.swingSword(); // => true

// Should all be true
p instanceof Person && p instanceof Class && n instanceof Ninja && n instanceof Person && n instanceof Class;


                //创建立即执行的匿名函数
                (function () {

                    //设置一个变量来分辨是最终使用还是内部初始化子类原型时使用
                    //如果是内部初始化子类原型时使用则不直接构造函数以减少运行不必要的代码
                    var initializing = false;

                    //先创建一个空类作为根类且作为全局变量记下来
                    this.Class = function () { };

                    //给根类实现扩展类的方法,这里的Class其实就是前面那句的this.Class的值,省略了this.而已
                    Class.extend = function (prop) {

                        //打上内部实例化标记
                        initializing = true;
                        //实例化父类作为子类的原型对象
                        var prototype = new this();
                        //重置内部实例化标记
                        initializing = false;

                        //把扩展对象的属性复制到子类的原型上
                        for (var name in prop)
                        {
                            prototype[name] = prop[name];
                        }

                        //创建一个类的壳
                        function Class() {

                            //如果不在内部使用状态且有构造函数就执行构造函数
                            if (!initializing && this.init)
                            {
                                this.init.apply(this, arguments);
                            }
                        }

                        //把前面创建的原型对象绑定了Class这个壳上, Class也就有了父类及扩展的方法及属性了
                        Class.prototype = prototype;

                        //设置constructor属性以便于以后用此做类型判断
                        Class.prototype.constructor = Class;

                        //让子类
                        Class.extend = arguments.callee;

                        //返回类
                        return Class;
                    };

                })();



    </script>

</body>
</html>
